# Хэширование

## Исследование хэш-функций 

Поддерживаем load-factor ~7 (размер хеш-таблицы - около 145000). Причин несколько - с большим load-factor лучше заметна равномерность распределения, а также больший размер хеш-таблицы питон уже не вывозит на гистограмме. 

### Целые числа

Остаток от деления на 1000: (я не очень понимаю, почему в условии просится такой модуль, но ладно)

![int mod](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/IntHashMod.png)

В увеличенном масштабе:

![int mod close](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/IntHashModClose.png)

Битовое представление:

![bit](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/IntHashBit.png)

Метод умножения с константой Кнута:

![knuth](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/IntHashBit.png)

Остаток от деления на 1000 очевидный бред из-за ограниченности. Битовое представление выглядит хорошо, скорее из-за того, что он переполняется (то есть берется модуль по 2^64) + берется модуль по размеру хеш-таблицы. Очевидно, если бы не было ни переполнений, ни взятия по модулю, распределение не было бы равномерным. Метод умножения с константой Кнута тоже норм, все равномерно.

Таблица времени работы:

|            |Запуск 1     |
|:---:       |:---:        |
|остаток     | 0.001102    |
|битовое     | 0.020363    |      
|Кнут        | 0.001546    |

Битовое представление довольно медленное за счет того, что приходится проходиться по всем битам и пересчитывать новое число в отличие от остальных хеш-функций, где выполняется парочку операций и все. Кнут медленнее, чем взятие по модулю, возможно, из-за использования арифметики с числами с плавающей запятой.

### Числа с плавающей запятой

Преобразование к (int) c последующим взятием битого представления инта:

![Float to int bit](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/FloatToIntBit.png)

