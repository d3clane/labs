# Хэширование

## Исследование хэш-функций 

### Целые числа

Остаток от деления:

![int mod](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/IntHashMod.png)

Битовое представление:

![bit](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/IntHashBit.png)

Метод умножения с константой Кнута:

![knuth](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/IntHashBit.png)

Битовое представление выглядит хорошо, скорее из-за того, что он переполняется (то есть берется модуль по 2^64) + берется модуль по размеру хеш-таблицы, но все равно получается хуже, чем взятие по модулю и метод умножения с константой Кнута тоже норм, все равномерно.

Таблица времени работы:

|            |             |
|:---:       |:---:        |
|остаток     | 0.001102    |
|битовое     | 0.020363    |      
|Кнут        | 0.001546    |

Битовое представление довольно медленное за счет того, что приходится проходиться по всем битам и пересчитывать новое число в отличие от остальных хеш-функций, где выполняется парочку операций и все. Кнут медленнее, чем взятие по модулю, возможно, из-за использования арифметики с числами с плавающей запятой.

### Числа с плавающей запятой

Преобразование к (int) c последующим взятием битого представления инта:

![Float to int bit](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/FloatToIntBit.png)

Битовое представление:

![Float bit](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/FloatBit.png)

Извлечение мантиссы:

![Mantissa](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/Mantissa.png)

Извлечение экспоненты:

![Exponent](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/Exponent.png)

Произведение мантиссы на экспоненту:

![ExpXMantissa](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/ExpXMantissa.png)

Битовое представление приведенного в int распределено с двух боков - последствие того, что числа типа -9 в битовом представлении очень большие и так совпало, что по моему модулю они все еще большие. Получается, что значения распределяются в две кучки [0; 10] и [-10; 0], остальное пусто - плохой хеш.

Просто битовое представление норм, все так же, как и в случае с битовым представлением для обычного int-а из хеш-функций для int. 

Извлечение мантиссы тоже хороший хеш, так как мантисса - 23 бита, то значений достаточно, чтобы заполнять всю хеш-таблицу. Для очень больших размеров таблиц (> 2^23) ничего начиная с какого-то номера заполняться не будет. 

Извлечение экспоненты - плохой хеш. Причина - значение экспоненты ужасно сильно ограниченно (8 бит на нее отведено) + мои числа в среднем не очень маленькие (то есть экспонента сильно отделена от нуля) и не очень большие (сильно отделено от максимального значения).

Произведение мантиссы на экспоненту - хороший хеш. Полагаю, что он хороший в основном благодаря мантиссе.

Таблица времени работы:

|                       |             |
|:---:                  |:---:        |
|Битовое инта           | 0.013696    |
|Битовое                | 0.022120    |      
|Мантисса               | 0.001167    |
|Экспонента             | 0.001453    |
|Экспонента на мантиссу | 0.001284    |

Битовое инта быстрее чем битовое. Полагаю из-за того, что в float заполнены верхние биты (экспонента) всегда, то есть операций много, пока число не занулится. При переводе в инт для чисел [0; 10] число зануляется за 4 сдвига, для [-10; 0] за все 32, в среднем получается лучше.

Мантисса, экспонента - все это работает быстро, потому что это просто сдвиг.

### Строки

Длина строки:

![Len](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/Len.png)

Сумма букв:

![Sum chars](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/Sum.png)

Полиномиальный:

![Polynomial](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/Polynom.png)

CRC32:

![CRC32](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/CRC32.png)

Длина строки ограничена (от 5 до 20) - плохой хеш.

Сумма букв $sum$ $'a' * 5 \le sum \le 'z' * 20$, то есть $485 \le sum \le 2440$ - тоже сильно ограниченная хеш-функция. При этом даже при взятии остатка от деления на 1000 все равно распределение отнюдь не равномерное. Возможно, из-за того, что получить какие-то суммы можно большим числом способов, чем другие.

Полиномиальный хеш и CRC32 распределяют равномерно.

Таблица времени работы:

|       |             |
|:---:  |:---:        |
|Длина  | 0.005352    |
|Сумма  | 0.012683    |      
|Полином| 0.011974    |
|CRC32  | 0.015893    |
 
Длина самая быстрая - надо просто пройтись и найти \0. Сумма / полином - медленнее, так как на пути надо еще считать значение. 

## Сравнение хеш-таблиц

Load factor:

Метод цепочек:

![Buckets factor](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/LoadFactorList.png)

Открытая адресация с линейным тестированием:

![Linear factor](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/LoadFactorLinear.png)

Открытая адресация с квадратичным тестированием:

![Quadratic factor](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/LoadFactorQuadratic.png)

Открытая адресация с методом двойного хеширования:

![Hash factor](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/LoadFactorHash.png)

У метода цепочек другой диапазон измерения, так как для него можно поддерживать load-factor > 1 в отличие от хеш-таблицы с открытой адресацией.

Видно, что оптимальный выбор для метода цепочек - около 2.75. 

Для хеш-таблиц с открытой адресацией оптимальные load-faсtor'ы примерно одинаковые - приму его равным 0.8.

Сгенерируем равновероятную последовательность из условия:

![Ops1](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/Ops1.png)

Другая последовательность:

![Ops2](https://github.com/d3clane/labs/blob/Lab5/Lab5/ReadmeAssets/imgs/Ops2.png)

Видно, что при малом load-factor таблицы работают медленно - тут решающим фактором является постоянное увеличение размера хеш-таблицы при добавлении новых элементов и, возможно, из-за большого размера она хуже кешируется. При увеличении load-factor результаты получаются лучше. При этом надо понимать, что брать гигантский load-factor для таблиц тоже не имеет смысла - будет замедление работы. В нашем случае данные выходят на некоторое плато. 

Все хеш-таблицы с открытой адресацией работают +- одинаково. Возможно, квадратичный метод чуть лучше, так как избегает кластеризации + нет нужды считать два хеша (что тоже долго). 

Хеш-таблица методом цепочек медленнее, так как список разбросан по памяти, плохо кешируется, долгий доступ к памяти выходит (и получается, что и рехеширование делать сложнее, так как списки по памяти разбросаны сильно).

## Сравнение идеального хэширования с обычным

Выберу хеш-таблицу с открытой адресацией и квадратичным тестированием.

Результаты измерений:

|            |             |
|:---:       |:---:        |
|Цепочки     | 0.226148    |
|Идеальное   | 0.119816    |      
|Открытая    | 0.213535    |

Цепочки и открытая показывают себя примерно одинаково - в целом, в ситуации, когда коллизий не очень много, это логично - искать по списку не так уж и сложно. В прошлом пункте проблема была больше в тяжести рехеширования. 

Идеальное хеширование сильно быстрее - как и ожидалось, так как все числа ищутся за O(1) в худшем случае. А если такого элемента в хеш-таблице нет, надо всего лишь проверить нужную клетку в отличие от, например, хеш-таблицы методом цепочек, где надо пройти по всему списку и проверить. 

Следовательно, когда множество ключей статично, стоит использовать хеш-таблицу с идеальным хешированием.

## Выводы

Про хеш-функции мало что можно сказать, все уже написал - какие-то подходят, какие-то нет, надо проверять для данных в конкретном случае. 

Хеш-таблица с открытой адресацией предпочтительнее хеш-таблицы методом цепочек, так как все данные расположены близко в памяти, а следовательно лучше кешируются. При этом по памяти, возможно, даже хеш-таблица с открытой адресацией лучше или такая же, как и таблица методом цепочек. Проблема в том, что для каждой ноды в списке выделяется новая структура с информацией + calloc может выделять больше памяти, чем мне нужно за раз. Получается, что каждая нода списка может поглощать очень много памяти. Если переписать на список с хорошим кешированием, хранящий данные в массиве, то проблема будет, как в динамических массивах - половина массива может пустовать. 

Среди методов тестирования для таблицы с открытой адресацией, лучшим, возможно, будет квадратичный метод, так как он избегает кластеризации и не высчитывает два хеша. 

Хеш-таблица с идеальным хешированием значительно лучше, чем аналогичные без идеального хеширования, а значит, если множество ключей статическое, имеет смысл использовать идеальное хеширование.
