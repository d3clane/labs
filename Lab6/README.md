# Деревья

## Наивное дерево поиска

100000 вставок, 50000 удалений для случайного набора элементов и для отсортированных последовательностей:

|     |        |
|:---:                  | :---:        |
| Вставка случайных     | 0.0130482    |
| Удаление случайных    | 0.0042582    |
| Вставка сортированных | 8.6759390    |
| Удаление сортированных| 4.9318496    |

Очевидно, вставка отсортированных работает очень долго, так как получается бамбук, вставка / удаление будут работать за O(n). 

При вставке / удалении случайных элементов работает быстро, так как в среднем на случайных данных высота наивной дерева поиска O(logn).

## AVL дерево

Вставки:

![AVL INSERTS](https://github.com/d3clane/labs/blob/Lab6/Lab6/ReadmeAssets/imgs/AVL_Inserts.png)

Удаления:

![AVL DELETES](https://github.com/d3clane/labs/blob/Lab6/Lab6/ReadmeAssets/imgs/AVL_Deletes.png)

Время работы для отсортированной последовательности из 1млн вставок и 500к удалений:

|             |              |
|:---:        | :---:        |
| Вставка     | 0.0910926    |
| Удаление    | 0.0554774    |

Вообще, работает дольше, чем вставки / удаления случайных. Возможно, из-за того, что в случае отсортированной последовательности балансировка дерева (ротейты) происходит чаще, то есть операций выходит больше на это. Но все равно это не O(n^2), так как дерево всегда балансируется и его высота O(logn). 

## Декартово дерево

Вставки:

![TREAP INSERTS](https://github.com/d3clane/labs/blob/Lab6/Lab6/ReadmeAssets/imgs/TREAP_Inserts.png)

Удаления:

![TREAP DELETES](https://github.com/d3clane/labs/blob/Lab6/Lab6/ReadmeAssets/imgs/TREAP_Deletes.png)

## Splay дерево

Вставки:

![SPLAY INSERTS](https://github.com/d3clane/labs/blob/Lab6/Lab6/ReadmeAssets/imgs/SPLAY_Inserts.png)

Удаления:

![SPLAY DELETES](https://github.com/d3clane/labs/blob/Lab6/Lab6/ReadmeAssets/imgs/SPLAY_Deletes.png)

## Выводы

Сравним Splay, Treap и AVL. Для вставок:

![SPA INSERT](https://github.com/d3clane/labs/blob/Lab6/Lab6/ReadmeAssets/imgs/SPA_INSERTS.png)

AVL < Treap < Splay.

В AVL дереве всегда поддерживается инвариант, поэтому точно известно, какая высота дерева, то есть операции гарантированно работают быстро. Для декартова дерева insert фактически достаточно тяжелая операция - сплит + два мерджа, которые работают за высоту дерева, возможно, поэтому, выходит дольше. Splay дерево же выполняет очень часто ротейты, а его время работы амортизированное. Дерево рассчитано на то, чтобы продвигать повыше к корню числа, которые недавно использовались. В нашем же случае все данные на входе случайные, поэтому подобная оптимизация никакого выигрыша не дает.

Сравнение для удалений:

![SPA DELETE](https://github.com/d3clane/labs/blob/Lab6/Lab6/ReadmeAssets/imgs/SPA_DELETES.png)

Splay ~ Treap < AVL

В AVL дереве Erase выполняется, как - найти в дереве вершины, найти нужную, чтобы заменить и не повредить свойство дерева поиска - выходит проход по всему дереву. Дальше, при подъеме вверх по дереву к корню надо проверить все инварианты и пофиксить их - выходит довольно много операций. 

В Treap Erase - поиск нужной вершины и мердж детей - не надо подниматься обратно.

Со Splay хороших объяснений придумать не могу - возможно, как-то помогла основная идея Splay дерева (вершины поднимались к корню).

Наивное дерево поиска вообще работает хорошо для случайного набора данных - ему не надо выполнять лишние операции для поддержание нормальной высоты, нет никаких скрытых констант. 
